// $Id: hlist.xp,v 45.0 1997/09/19 05:46:27 jthomas Exp $
// Copyright (C) 1997, The University of Texas at Austin.

layer ds hlist [ ds ] stable curs_state annotation retrieval_sometimes

!#include <string.h>  /* memset() */

!#include "qopt.h"
!#include "hlist.h"

#define RESET_OPTIMIZE  (strcmp(%a.hint, "") != 0)

/********************
hlist is a time-stamp ordered hash-list that is used by the leaps compiler.  
The timestamp field is input to the layer via the annotaion:

    llist timestamp is <timestamp-field-name> key <field> [ option xxx ]

If anything is supplied by xxx, then the RESET_OPTIMIZE optimization is called.

The semantics of hlist are the same as llist:

   (0) timestamps are assigned increasing values; elements are
       given timestamps when they are inserted, and are assigned
       new timestamps when they are deleted.  (Updates are modeled
       as insertions and deletions).  llist does not assign timestamp 
       values.

   (1) every element insertion is placed at the head of the list.
       This assumes that new elements will have the most recent
       timestamp.  Thus, llist effectively maintains elements in 
       (descending) timestamp order.

   (2) As mentioned above, updates are insertions followed by 
       deletions.  If there are updates, llist ignores them,
       even updates to timestamps.  Thus, if you're not careful,
       llist might not even maintain the list of elements in 
       descending timestamp order.

   (3) llist is stable, in that elements are unlinked when deleted, 
       but their pointers remain intact.  Thus:

       originally:            A <-> B <-> C <-> D ...

       now delete B yields:   A <-> C <-> D ...
                              ^     ^
                              |--B--|  (that is, B still points to
                                        its former neighbors after deletion).

       Basically, what this means is that when an element is
       deleted, it is pointing to a list of deleted and undeleted
       elements (note that the deleted elements will come before
       undeleted elements).  This list of elements is a subset
       of the list of elements that were not deleted at the time
       the given element was deleted.  It is a subset, since 
       some elements of this list may have been deleted subsequently.

       An unusual property of llist is that it supports a form
       of cursor stability.  An element can be deleted from 
       underneath a cursor.  Since elements still maintain their
       forward pointers, retrievals can continue.  However, it 
       is possible that one or more deleted records will be 
       encountered before one is again traversing the llist.
       Since deletions update element timestamps, it is a simple
       matter upon advancement to check to see if the timestamp
       is still in the range of timestamps of interest.

   (5) expect queries to involve predicates on the timestamp field.
       example: if _ts is the timestamp field, one might get the query:

       "age > 40 && _ts < domtimestamp"

       This means that we are only interested in objects whose
       timestamp is less than the variable domtimestamp.

       Note: we may optimize container searches by ignoring those records 
       whose timestamp is greater than domtimestamp.  This optimization 
       could be put into reset_start, which would skip over the 
       appropriate records.

       Similarly, the query:

       "age > 40 && _ts > domtimestamp"

       would allow llist searches to terminate early, as once an 
       element has been found whose timestamp is less than domtimestamp
       and terminating a search whenever an object is reached whose
       timestamp is < domtimestamp.  We can accomplish this by stealing
       code from the end_adv operation for odlist.

       In general, there are 3 cases that are generated by leaps, 
       where P stands for predicate without timestamp qualification.

       case 1: predicate is P

       // occurs only in evaluating negated CEs, in particular
       // searching containers.  We don't have to worry about cursor
       // stability here since we scan the container "atomically".

       reset_start        cursor.obj = container.first;

       adv                cursor.obj = cursor.next;

       end_adv            !(cursor.obj)

       query              P

       case 2: predicate is P && $._ts <=? dom_timestamp
       (where <=? means < or <=)

       // occurs normally when evaluating positive CEs.  We need
       // to worry about cursor stability in this case.  The output
       // of query applies the timestamp clause to ensure that we
       // skip over deleted elements.

       reset_start        // find first element whose timestamp
                          // satisfies timestamp clause
                          // can optimize for multiple reset-starts

       adv                cursor.obj = cursor.next;

       end_adv            !(cursor.obj)

       query              $._ts <=? dom_timestamp && P

       // note that by placeing the timestamp qualification
       // first, we can improve performance

       case 3: predicate is P && $._ts >=? dom_timestamp

       // occurs only in evaluating negated CEs, particularly
       // searching shadow containers.  We don't have to worry about
       // cursor stability here since we sscan the shadow "atomically".
 
       reset_start        cursor.obj = container.first;

       adv                cursor.obj = cursor.next;

       end_adv            !(cursor.obj) || !($._ts >=? dom_timestamp)

       query              P

      

Finally: RESET_OPTIMIZE = 1 generates a possible optimization for
       reset start (and presumably reset end).  The idea is that
       because llists are stable - meaning that insertions only occur
       at one end, if the timestamp predicate hasn't changed, it
       is possible to reset to the first element that qualified
       the timestamp predicate.  Thus, the first reset_start will
       find the first element.  subsequent to this, say, 1000 insertions
       take place, all with greater timestamps.  Instead of reading
       all 1000 of these on a reset (only to skip over these elements),
       one can reset to the element identified on the first reset.
**********************/


cursor_func link(cursor)
{
char   hash_func[100];

   strcpy(hash_func, "P2_");
   strcat(hash_func, %a.hash_typeptr->typename);
   strcat(hash_func, "_hash");

   %{ { int i;
        i = %v.hash_func(cursor.%a.hash_field, %a.size);
        cursor.next = container.first[i];
        cursor.prev = 0;
        if (cursor.next) { 
           cursor.next->prev = cursor.obj;
        }
        container.first[i] = cursor.obj;
      }
   %}
}

cursor_func unlink(cursor)
{
char   hash_func[100];

   strcpy(hash_func, "P2_");
   strcat(hash_func, %a.hash_typeptr->typename);
   strcat(hash_func, "_hash");

   %{
    // Note record prev and next ptrs still intact for advancing.
    if (cursor.prev) {
        cursor.prev->next = cursor.next;
    } else {
        int i;
        i = %v.hash_func(cursor.%a.hash_field, %a.size);
        container.first[i] = cursor.next;
    }
    if (cursor.next) {
        cursor.next->prev = cursor.prev;
    };
   %}
}


// xforms


xform(element, container, cursor)
{
   // Step 1:  add basic fields

   add element   : struct element *next; 
   add element   : struct element *prev; 
   add container : struct element *first[%a.size]; 

   // Step 2:  remember additional info about annotations

   %a.ts_typeptr   = find_data_type(element, %a.ts_field);
   %a.ts_bi        = %a.ts_typeptr->bounds_impact;
   %a.hash_typeptr = find_data_type(element, %a.hash_field);
   %a.hash_bi      = %a.hash_typeptr->bounds_impact;

   if (RESET_OPTIMIZE) {
      // Step 3:  the following additions are optional for the
      //          reset optimization
   
      add cursor   : int            timestamp;
      add cursor   : struct element *reset_position;
   }   

   xform(element, container, cursor);
}


ddlhint(argc, argv)
{
  limit 4 arguments;
  get_ddlhint_argument(%a.ts_field,   argv[1]);
  get_ddlhint_argument(%a.hash_field, argv[2]);
  get_ddlhint_argument(%a.size,       argv[3]);
  get_ddlhint_argument(%a.hint,       argv[4]);
}
      

#define HASH_BUCKET_SEARCH 100

#define COST0   MAX_QOPT_COST
#define COST1   MAX_QOPT_COST
#define COST2   HASH_BUCKET_SEARCH

optimize(cursor)
{
BOUNDS b;

  // Step 1:  call lower layers to get their results

  optimize(cursor);

  // Step 2:  use hlist only if the predicate involves a point
  //          retrieval on the hashed key

  if (use_layer(te, &b, cursor, predicate, %a.hash_field, %a.hash_bi) != 2)
     return;

  strcpy(%c.hash_pred, b.upper);

  // Step 3:  now do the same as in llist

  if (cost>COST2) {
     cost  = COST2;
     layer = %ln;
     retrieval_direction = 0;

     // now determine which case applies - see comments above

     define_bounds(te, &(%c.b), cursor, predicate, %a.ts_field, %a.ts_bi);

     if (%c.b.bottom) {  // -inf bottom
        if (%c.b.top) {  // + inf top
           %c.which_case = 1;
        } else {
           %c.which_case = 2;
           simplify_predicate(predicate,&(%c.b),%a.ts_field,FALSE,%c.reduced);
        }
     } else {          // lower-bound specified
        if (%c.b.top) { // + inf
           %c.which_case = 3;
           simplify_predicate(predicate,&(%c.b),%a.ts_field,TRUE,%c.reduced);
        }
        else {
           %c.which_case = 1;
           warning(3, "llist cannot handle both upper and lower bounds on timestamps");
        }
     }
  }
}

// retrieval operation - query

query(cursor)
{
char  *p = 0;
char  lim[100];
char  func[50];

   switch(%c.which_case) {
   case 1: p = bind_predicate(te, cursor, obj_type, predicate);
           %{
              %v.p
           %}
           break;
        
   case 2: p = bind_predicate(te, cursor, obj_type, %c.reduced);
           strcpy(lim, %c.b.upper);
           if (%c.b.inc_lower) {
              strcpy(func,"int_LE");
           } else {
              strcpy(func,"int_LT");
           }
           %{
              (%v.func(cursor.%a.ts_field, %v.lim) && %v.p)
           %}

           break;

   case 3: p = bind_predicate(te, cursor, obj_type, %c.reduced);
           %{
              %v.p
           %}
           break;
   }
   xfree(p);
}


// retrieval operations - adv, rev

adv(cursor)
%{
    cursor.obj = cursor.next;
%}


rev(cursor)
{
   warning(3, "llist does not support rev");
}

// retrieval operations - end_adv

end_adv(cursor)
{
   char   lim[100];
   char   func[50];

   // See if the cursors predicate specifies a lower bound

   if (%c.b.bottom) {
       // The cursors predicate does not specify a lower bound.
       // We have advanced to the end of the list iff cursor.obj 
       %{
       (!cursor.obj)
       %}
   } else {
       // The cursors predicate specifies a lower bound.
       // We have advanced to the end of the list iff cursor.obj == 0
       // or we have advanced to a record whose ofield is less than the lower bound.
       strcpy(lim, %c.b.lower);
       if (%c.b.inc_lower) {
           strcpy(func,"int_LT");
       } else {
           strcpy(func,"int_LE");
       }
       %{
           (!cursor.obj || %v.func(cursor.%a.ts_field, %v.lim))
       %}
   }
}



// retrieval operations - end_rev


end_rev(cursor)
{
   warning(3, "llist does not support end_rev");
}


// retrieval operations - reset_start

reset_start(cursor)
{
char   lim[MAX_IDENT_LEN];
char   func[MAX_IDENT_LEN];
char   hash_func[100];
char   hash_value[MAX_PRED_LEN];

   strcpy(hash_func, "P2_");
   strcat(hash_func, %a.hash_typeptr->typename);
   strcat(hash_func, "_hash");

   strcpy(hash_value, %c.hash_pred);
   replace_cursor_refs(te, cursor, hash_value);

   switch(%c.which_case) {
   case 1:
   case 3: 
      %{ { int i;
           i = %v.hash_func(%v.hash_value, %a.size);
           cursor.obj = container.first[i];
         }
      %}
      break;
   case 2: 
      if (RESET_OPTIMIZE) {
         if (%c.b.inc_upper) {
            strcpy(func, "int_GT");
         } else {
            strcpy(func, "int_GE");
         }
         strcpy(lim, %c.b.upper);
   
         %{
            if (cursor.timestamp == %v.lim) {
               cursor.obj = cursor.reset_position;
            } else {
               int i;
               i = %v.hash_func(%v.hash_value, %a.size);
               cursor.obj = container.first[i];
               cursor.timestamp = %v.lim;
            }
            while (cursor.obj && %v.func(cursor.%a.ts_field, %v.lim)) {
               cursor.obj = cursor.next;
            }
            cursor.reset_position = cursor.obj;
         %}
      } else {
         %{ { int i;
              i = %v.hash_func(%v.hash_value, %a.size);
              cursor.obj = container.first[i]
            }
         %} 
      }
      break;
   }
}

// retrieval operations - reset_end

reset_end(cursor)
{
   warning(3, "llist does not support reset_end");
}


// non-retrieval operations - init_cont

init_cont(container)
%{
   init_cont (container);

   memset((void *) container.first, 0, (%a.size * sizeof(char*)));
%}

init_curs(cursor)
{
   %{
      init_curs(cursor);
   %}
   if (RESET_OPTIMIZE)
   %{
      cursor.timestamp = -1;
   %}
}

// non-retrieval operations - insert

insert(cursor, record)
%{
   insert(cursor, record);
   call link(cursor);
%}


// non-retrieval operations - delete

delete(cursor)
%{
    call unlink(cursor);
    delete(cursor);
%}


// non-retrieval operations - update

upd(cursor, field, expr)
%{
   upd(cursor, field, expr);
%}
        
// non-retrieval operations - pos

pos(cursor, expr) 
%{
    pos(cursor, expr);
%}


