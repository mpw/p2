@c $Id: language.texi,v 45.0 1997/09/19 05:42:06 jthomas Exp $
@c Copyright (C) 1997, The University of Texas at Austin.

@node    P2 Language, P2 Operations, Introduction, Top
@chapter P2 Language
@cindex P2 language

@cindex format

P2 is a superset of ANSI C.
Thus, a P2 source file has the format of a C file with support
for the container/cursor abstractions.
These will be discussed in detail below. 
In addition, P2 supports C++ style comments
(where everything to the right of a @code{//} is ignored).

@menu
* The Container/Cursor Overview::  General description of the 
                                        Container/Cursor paradigm
* Operation Usage::             Special operations and their usage
* Container Declarations::      
* Cursor Declarations::         
* Type Expressions::            Describing the implementation of a container
* Generic Containers/Cursors::  Proxies for concrete containers/cursors
* Element Keyword::             Generating the transformed type
* Comprehensive Example::       
* Type Expression Constraints::  
* Composite Cursors::           The "compcurs" structure
@end menu

@node The Container/Cursor Overview, Operation Usage, P2 Language, P2 Language
@section The Container/Cursor Overview

@cindex container, defined
@cindex cursor, defined
@cindex container/cursor paradigm
@cindex qualified cursor

The paradigm used in P2 is the @dfn{container/cursor model}. 
A @dfn{container} is a collection of objects called @dfn{elements}. 
Elements are  referenced  by a structure called a @dfn{cursor}. 
With respect to the container, a cursor can:
@itemize @bullet
@item
move backwards and forwards through the container

@item
start at the beginning or the end of the container

@item
add, delete, swap, and update elements 

@end itemize

@cindex qualified cursor
@cindex cursor predicate
@cindex cursor orderby clause
@cindex predicate
@cindex ordering    

A @dfn{qualified cursor} points only to elements that share some
characteristic. Qualified cursors have two properties: a
@dfn{predicate}, which restricts the cursor to point only to elements
that satisfy the predicate, and an @dfn{orderby clause}, which specifies the
order in which the cursor retrieves elements from the container.

The power of qualified cursors is the ability of the P2 system to
optimize operations based on their qualifications. If a cursor is
restricted to all even numbers, then the procedure that is generated by
P2 for searching that container will have this test embedded. The
disadvantage is that to a certain extent, we cannot have dynamically
(run-time) cursor predicates that are common in interactive
environments. 

P2 programs are written in terms of operations on cursors and containers
and without regard to how they are implemented.  This, in principle,
enables different implementations of cursors and containers to be
"plugged in" without requiring program modifications.

Ultimately, however, a specification of how cursors and
containers are to be implemented must be provided to the
P2 compiler, as the compiler replaces cursor and container
declarations and operations with their corresponding C 
implementation.  An implementation specification comes
in two parts: a type expression and its annotations.

@cindex type expression
@cindex annotation

A @dfn{type expression} is a composition of P2 building blocks;
it specifies a stacking of layers that defines the general
characteristics of the data structure that P2 is to generate.
Additional information, such as key fields, array sizes,
etc., are called @dfn{annotations}.  The combination of type
expressions and annotations is the sole means for
specifying data structure implementations.  Among the
characteristics that can be defined by type expressions
and annotations are:

@itemize @bullet
@item
Whether elements are ordered or not, and if so, under what field is the
element ordered.

@item 
If the container uses transient or persistent storage.

@item
Details of searching and deletion strategies.

@item
Whether or not the container should contain a maximal number 
  of elements

@end itemize

As mentioned earlier, the power of P2 programs stem
from the separation of cursor and container abstractions
and their implementations; by altering a P2 program's
type expression(s), containers and cursors can be assigned
radically different implementations.  This significantly
simplifies tuning.

@ignore
The power of a type expression is in its interchangeability---a container
can be changed from a linked list implementation to a binary tree
implementation without changing the operations in the body of the code.

However, we are developing strategies to cope with this and investing
new operations and techniques.
@end ignore


@node Operation Usage, Container Declarations, The Container/Cursor Overview, P2 Language
@section Operation Usage

@cindex primes

For example, suppose we have a container called primes with the elements
@samp{2 3 5 7 11 13 17 23 29}. We declare a cursor @code{c} that ranges
over all elements of  the
container. After we initialize the cursor, we can perform  a
reset  which  positions the cursor on the first object:

@example
@group
c
2 3 5 7 11 13 17 23 29
@end group
@end example

We can iterate through the list using successive advance (@code{adv})
operations.
Three advances positions the cursor at @samp{7}.


@example
@group
      c
2 3 5 7 11 13 17 23 29
@end group
@end example

We can backtrack using the reverse (@code{rev}) operations.
A reverse and cursor is pointing at @samp{5}.

@example
@group
    c
2 3 5 7 11 13 17 23 29
@end group
@end example

Two more reverses and cursor is pointing at @samp{2}. 

To test whether a cursor has gone past the end of the container,
the operations @code{end_adv} and @code{end_rev} are provided.
@code{end_adv} returns @code{true} (@code{1})
if an advance operation positions the cursor past the 
end of the container;
@code{end_rev} does the same for the reverse operation.  
If another reverse is attempted, then @code{end_rev}
returns @code{true} (@code{0}). 

Normally, programmers do not call the @code{adv} and @code{end_adv}
operations directly, but use the P2 @code{foreach(c)} loop construct.
@code{foreach(c)} uses cursor c to iterate over  elements of
a container.  If c is qualified, then only those elements
that satisfy c's predicate are examined.  P2 expands @code{foreach(c)}
into calls to @code{adv(c)} and @code{end_adv(c)}.
The @code{rofeach(c)} loop
construct does the same, except it traverses elements of
the container in the opposite order, using @code{rev(c)} and 
@code{end_rev(c)} operations.



Using the primes container, a cursor @code{q} qualified over all
numbers ending in the digit @samp{7} will either point to @samp{7} or
@samp{17}. Therefore if @code{q} is initialized and then a reset_start
operation is performed on it, @code{q} will point to @samp{7}. 
A single advance would point @code{q} next to @samp{17}. 

Cursors are also used to delete objects. In the previous example, if the
delete operation is invoked, then @samp{17} would be removed from the
container, but the cursor would still point to the location occupied by
the @samp{17}.
If an advance is performed, the cursor would be positioned on the next qualified
element, which in this case would be @code{NULL}, since there are no
elements ending in the digit @samp{7} past @samp{17}. 

@example
@group
                     q
2 3 5 7 11 13 23 29
@end group
@end example

An insert operation performed with the number @samp{47} would insert the
element somewhere in the container. It is up to the particular type
expression of the container as how to  elements should be added
(whether it places it at the head of the list,
the tail of the list, or keyed by some field).

@example
@group
                           q
2 3 5 7 11 47 13 17 23 29
@end group
@end example

More details will be given in subsequent sections.

@node Container Declarations, Cursor Declarations, Operation Usage, P2 Language
@section Container Declarations

@cindex   container declaration

A container is a collection of elements of @var{element_type} that is
implemented by some type expression. The type expression may need
additional information, which is the annotation list.  The syntax is:

@example
@group
container_declaration : @code{container} @code{<} element_type @code{>}
                       @code{stored_as} type_expression_name
                       @code{with} @code{@{} annotation_list @code{@}} 
                       identifier_declarator_list @code{;}
annotation_list : @{ annotation @code{;} @}*
@end group
@end example


For example, let us declare two types that we will use in our
examples. A type for storing prime numbers called prime_num_type and a
type for storing employee data, emp_type. 

@example
@group
typedef struct @{
    int num;
@}  prime_num_type

typedef struct EMPLOYEE @{
    char name[20];  // last name
    int  age;      
@} emp_type;
@end group
@end example


Next, we will define 
a container storing a linked list of prime numbers: 

@example
@group
container < prime_num_type > stored_as linked_list
with @{ @} prime_container, *pointer_to_prime_container;

// @r{alternate way of defining the above}
typedef container < prime_num_type > stored_as linked_list 
with @{ @} PRIME_CONTAINER_TYPE;

PRIME_CONTAINER_TYPE prime_container, *pointer_to_prime_container;
@end group
@end example

Now for the employees example:

@example
@group
container < struct EMPLOYEE > stored_as linked_list
with @{ @} emp_cont, emp_cont_arr[4];       // array of containers
@end group
@end example

Note that @code{linked_list} is the name of a type expression
(whose definition we will give later on) and that it 
has no annotations.

@node Cursor Declarations, Type Expressions, Container Declarations, P2 Language
@section Cursor Declarations
@cindex   cursor declaration

A cursor is a structure that points to elements in a container. A cursor
can point in only one container, but a container may have more than one cursor.
The syntax for a cursor declaration is: 

@example
@group
cursor_declaration:  @code{cursor} @code{<} container_name @code{>}
                     [ predicate_specifier ] 
                     [ ordering_specifier ]
                     identifier_declarator_list @code{;}
predicate_specifier: @code{where} predicate
ordering_specifier:  @code{orderby} orderby_clause
@end group
@end example

Cursors have two optional properties: a predicate and an orderby clause. 

A cursor predicate specifies a subset of the elements in the container to which
the cursor my be bound. A predicate is specified as a double-quote enclosed C
boolean expression with the extensions that (1) the dollar sign refers to
the cursor object and (2) string constants are enclosed within single quotes.
P2 automatically converts string relational operations into
appropriate calls to @code{strcmp()}.
Any expression for the predicate can be specified, but P2 is
able to make certain optimizations on only a subset of predicates known
as @dfn{structured terms}.
This subset of predicates is defined by the following grammar:

@example
@group
predicate: term
         | predicate @code{ && } term // @r{Blanks are important}
term:      field relop value          // @r{Structured term}
         | value                      // @r{Unstructured term}
field:     @code{$.} @var{field_name} // @r{@code{$} is the cursor alias}
relop:     @code{==} | @code{>=} | @code{<=} | @code{<} | @code{>} | @code{!=}
value:     @var{non-blank_character_sequence} | 
           @var{string-literal}
@end group
@end example

@cindex structured predicate
@cindex unstructured predicate

A predicate is a series of terms joined by @code{&&}. A term is either
a relational expression, which is called a @dfn{structured term}, or
not, which is called an  @dfn{unstructured term}. Unstructured terms
must be written in parentheses and without spaces.

An example of a structured term is @code{"$.name == 'Batory, Don' "} where
an example of an unstructured term would be
@code{"($.age>40||$.age<30)"}. 
Anytime a disjunction (@code{||}) appears,  the expression is unstructured.
So whenever a disjunction is used, the term it appears in must be written
without blanks and in parenthesis.
Also note that predicates can contain function calls such as 
@code{"(fn($.name,currname))"},
in which case they are unstructured as well.
String literals are enclosed within single quotes (e.g., @code{'Batory'}).
A string literal cannot have embedded quotes, single or double. 

Here are more examples of structured P2 predicates on an employee
record type with a name string field and an integer age field:
@example
@group
"$.age > 15"                  // @r{age field greater than 15}
"$.age == 15"                 // @r{age field equals 15}
"$.name >= 'B' && $.name < 'C' && $.age > 40"
                              // @r{name field begins with letter 'B'}
                              // @r{and age field greater than 40}
"$.age > x"                   // @r{age field greater than value of variable x}
"$.age > x && $.age < y"      // @r{age field falls within range (x,y)}
@end group
@end example

    Note that spaces are important in the above predicates.

    Here are more examples of unstructured P2 predicates:

@example
@group
"($.age>15)"                  // @r{enclosed within () and without blanks}
"(is_old($.age))"             // @r{function call where age field passed}
                              // @r{as parameter}
"($.name>='B'&&$.name<'C'&&$.age>40)"
                              // @r{same as third structured example above}
"(($.name>='B'&&$.name<'C')||$.age>40)"
                              // @r{name field begins with 'B' or age > 40}
@end group
@end example

    Here are examples of illegal P2 predicates:

@example
@group
"$.age> 15"                   // @r{missing blank before >}
"($.age>15"                   // @r{missing right parenthesis}
@end group
@end example

@cindex cursor orderby clause

An @dfn{orderby clause} specifies the field and
sort direction for retrieved elements. The syntax
for the orderby clause is:

@example
@group
orderby_clause: @code{ascending} @var{field_name}
              | @code{descending} @var{field_name}
              | @var{field_name}  
@end group
@end example

The reserved word @code{ascending} (@code{descending}) specifies to
sort in increasing (decreasing) order.
The field @var{field_name} is the ordering key.
Depending on the type of the key, the sorting method
is numeric or lexicographic.
Sorting on multiple keys are not currently supported.
The third case defaults to ascending by the @var{field_name} key.



For our first example, the following cursor declaration declares a
cursor variable over the prime number container.
The cursor is qualified to match only numbers ending in
the digit @samp{1} and to return the elements in increasing order. 

@example
@group
cursor < prime_container >
  where "($.num%10) == 1" // @r{Unstructured Predicate}
  orderby ascending num // @r{Orderby clause}
prime_cursor;           // @r{cursor variable}
@end group
@end example

The next example is a cursor for the employees container, which will
range over all employee elements whose name begins with an @code{M}. In
addition, these elements are retrieved in reverse order ( larger numbers
appear first ) by their ages. 

@example
@group
cursor < emp_cont > 
    where "$.name >= 'M' && $.name < 'N'"
    orderby descending age
@end group
@end example


@ignore exbody
@example
@group
@end group
@end example
@end ignore



@ignore

@cindex cursor, first-class object

Cursors are first-class objects. For example, let's define a cursor
typedef @code{C}, cursor @code{v} of type @code{C}, and a formal cursor
parameter @code{x} of type @code{C}:

@c The code below is taken from sample.p2
@example
typedef cursor <k> where "$.temp >= 98.6" orderby ascending name C;
C v;
int f( C x )
@{
  @dots{}
@}
@end example

Then @code{c} can be passed as an actual parameter to formal parameter
@code{x}, and assigned @code{c} to temporary cursor variable @code{v}:


@example
f( c ); // Legal.
v = c;  // Legal.
@end example


@end ignore

@c =========================================================================

@node Type Expressions, Generic Containers/Cursors, Cursor Declarations, P2 Language
@section Type Expressions

@ignore
@example
@group
typex_definition :       @var{layer_name}
                       | @var{layer_name} @code{[} 
                            typex_definition @{ @code{,} typex_definition @}* 
                         @code{]}
@end group
@end example
@end ignore

@menu
* Type Expression Declarations::  
* Type Expression Annotations::  
* Automatic Repetition::        
@end menu

@node Type Expression Declarations, Type Expression Annotations, Type Expressions, Type Expressions
@subsection Type Expression Declarations

@cindex type expressions
@cindex typex declaration

A @dfn{type expression} is a composition of layers which represents 
an  implementation for the container. 
A type expressions is defined using a @dfn{typex declaration} which is a
sequence of zero or more type assignments.
The typex declaration assigns a symbolic name to type expressions.  
These names may be subsequently referenced to specify the
container implementation.
Type expression names can not end with a digit,
but are otherwise ordinary C identifiers.


@example
@group
typex_declaration :      @code{typex} @code{@{} typex_assignment* @code{@}} ;
typex_assignment :       typex_name @code{=} typex_definition @code{;}
@end group
@end example


For example, the following typex declaration declares two type
expressions, named s and t:

@example
@group
typex @{
  s = conceptual[slist[delflag[array[transient]]]];
  t = conceptual[odlist1[odlist2[malloc[transient]]]];
@}
@end group
@end example

@cindex term

Interpreting type expressions requires some background on
what they actually mean.  A @dfn{term} of a type expression is
a P2 layer (or component).  Every P2 component encapsulates
a consistent data type and operation mapping for cursors,
containers, and their elements.  A type expression is a 
composition of layers that defines a sequence of mappings 
that transforms a P2 program into a C program.  Thus, 
to understand what a type expression means requires 
understanding the mapping that is performed by each layer 
of the type expression.

With this as a background, let's analyze
these expressions to see what they mean. The full meanings
of the individual layers are given in detail in @xref{P2 Layers}. For
@code{s}:

@itemize @bullet
@item
The @code{conceptual} layer is actually a built-in composition of many
P2 layers that accomplish sorting, loop rewrites etc.  It is
typically the first layer of every type expression.
 
@item
The @code{slist} layer links together elements of a container onto
a singly linked list in order of insertion. 

@item
The @code{delflag} layer 
the delflag layer rewrites an element delete operation into
an element update that marks an element deleted; the storage
 space for an element is not reclaimed.

@item 
The @code{array} layer provides storage for the elements in a
preallocated array. The implementation of array ignores deletions, so
the @code{delflag} layer is needed above the @code{array} layer. 

@item 
The @code{transient} layer stores the element in main memory. This is
different than the @code{mmap_persistent} layer which stores the element
to disk.

@end itemize

In summary, @code{s} is a layer which stores its elements in an array (which
are also linked in a list) in main memory. Let us analyze @code{t} similarly:

@itemize @bullet
@item
The @code{conceptual} layer is actually a built-in composition of many
P2 layers that accomplish sorting, loop rewrites etc.  It is
typically the first layer of every type expressions.
 
@item
The @code{odlist1} layer links together elements of a container via an
ordered doubly-linked list. The ordering for this layer depends on the
annotation. 

@item
The @code{odlist2} layer is exactly like @code{odlist1},  though the
ordering key may be different.

@item 
The @code{malloc} layer provides storage from the heap for each new
element allocation. 

@item 
The @code{transient} layer stores the element in main memory. 

@end itemize

So @code{t} allocates space for the elements on demand and links the
elements together using two keys. 

@node Type Expression Annotations, Automatic Repetition, Type Expression Declarations, Type Expressions
@subsection Type Expression Annotations

Besides the layer parameters, a layer may have 
additional parameters called annotations.  The only layer 
of type expression @code{s} that has an annotation is @code{array}.  
The @code{array}  needs the size of the array to allocate.  
If we wish to set that value to 200, then we could declare
a container that can store up to 200 primes as:


@example
@group
typex @{ 
     s = conceptual[slist[delflag[array[transient]]]];   
@}

container < prime_num_type > stored_as s with @{
    array size is 200;
@} prime_container;
@end group
@end example

In expression @code{t}, only the @code{odlist} layer has
an annotation.  This layer  stores elements onto an ordered, 
doubly-linked list.  The key or sort field is the annotation
of @code{odlist}.  Note that @code{odlist} appears twice in @code{t}, and each
instance  can have its own distinct key.  To ensure
that the proper annotation is associated with the proper
instance of @code{odlist}, layer names are followed by a unique
digit. Therefore a layer can appear at most 10 times in a type
expression (there is a way around this limit in @ref{Automatic Repetition}). 
Using  the employee example, we can declare:

@example
@group
typex @{ 
     t = conceptual[odlist1[odlist2[malloc[transient]]]];
@}

container < emp_type > stored_as t with @{
    odlist1 key is name;
    odlist2 key is age;
@} emp_cont1; 

cursor < emp_cont1 > orderby age emp_curs1;
cursor < emp_cont1 > orderby name emp_curs2;
@end group
@end example

@node Automatic Repetition,  , Type Expression Annotations, Type Expressions
@subsection Automatic Repetition

@cindex automatic repetition

One more feature in type expressions is @dfn{automatic repetition}. If a layer
takes a single annotation, and two annotations are given, then the layer
is automatically repeated. If no annotations are given, then the layer
is automatically deleted. 

For instance, let us define type expression @code{u}:

@example
@group
typex @{
    u = conceptual[bintree[odlist[malloc[transient]]]];
@}
@end group
@end example

The actual type expression will change with respect to these container
declarations:

@example
@group
container < emp_type > stored_as u with @{
    bintree key is name;
    odlist  key is age;
@} emp_cont1; 

container < emp_type > stored_as u with @{
    bintree key is name;
    bintree key is age;
@} emp_cont2; 

container < emp_type > stored_as u with @{
    odlist key is name;
    odlist key is age;
@} emp_cont3; 
@end group
@end example

In @code{emp_cont1}, the annotations will preserve the type expression
@code{u} as before. However, @code{emp_cont2} will cause the @code{bintree}
layer to be duplicated and the @code{odlist} layer to disappear since there
are two @code{bintree} annotations and no @code{odlist} annotations. Therefore the
type expression is changed to the equivalent of: 
@w{@code{conceptual[bintree[bintree[malloc[transient]]]]}}. The last
container declaration has no @code{bintree} annotations but two @code{odlist}
annotations, therefore the type expression is equivalent to:
@w{@code{conceptual[bintree[bintree[malloc[transient]]]]}}.

Automatic repetition can be combined with the method of distinguishing
layer instances by their last digit,
so declarations like the one below are legal:

@example
@group
typex @{
    u = conceptual[bintree1[odlist[bintree2[malloc[transient]]]]];
@}
container < emp_type > stored_as u with @{
    bintree1 key is name;
    bintree1 key is age;
    bintree2 key is name;
@} emp_cont1; 
@end group
@end example

The above example means that for container @code{emp_cont1}, the first
@code{bintree} layer is duplicated, the @code{odlist} layer is deleted,
and the second @code{bintree} layer appears only once. 

@c =========================================================================

@node Generic Containers/Cursors, Element Keyword, Type Expressions, P2 Language
@section Generic Containers/Cursors

@cindex generic container

A @dfn{generic container} is a proxy for a @dfn{concrete} (i.e. non-generic)
container. 
The motivation for generic containers is to enable the defintion of
procedures that operate
over several containers that share the same element type. 

The
syntax for the declaration is:

@example
@group
generic_container_declaration: @code{generic_container} 
                @code{<} element_type_specifier @code{>} 
@end group
@end example

Suppose we wish to write a @code{print_size} function which returns the
number of elements in the container. Additionally, we have several different
containers of emp_types; each with a different type
expression.  This means that the C struct type for each container
would be different, thus causing one @code{print_size()} function
to be written for each container type.  This is awkward.

Generic containers were introduced to eliminate this problem.
One @code{print_size()} function can be written, which takes @emph{any}
container of @code{prime_num_type} elements as an argument.
Here is how such a  container would be written:

@ignore
Special  operations can be performed on generic container just as on
concrete containers, but  after the address of a generic container has been
bound to a concrete container. This is done  by passing the
concrete container as an actual to a generic container formal parameter or by
assigning it to a generic container variable.
@end ignore


@example
@group
container < emp_type > stored_as linked_list with @{
@} emp_cont

typedef generic_container < emp_type > GK;

void print_size( GK cont, char *name)
@{
    printf("Size of container %s = %d",
        name, cardinality(cont));
@}

main()
@{
    ...
    print_size((GK) &emp_cont,"Employee #1 Container");
@}
@end group
@end example

will declare a type @code{GK} that can be used in the procedure
@code{print_size}. This procedure will work for all containers based on
the @code{emp_type}. The @code{cardinality} procedure is one of P2's
special container operations. 


@cindex generic cursor
@cindex concrete cursor
@cindex cursor, generic
@cindex cursor, concrete

A @dfn{generic cursor} is a proxy for a concrete cursor
in the same way as a generic container is a proxy for a concrete container.
The syntax is similar as well:

@example
generic_cursor_declaration: @code{generic_cursor} 
                            @code{<} element_type_specifier @code{>}
                         identifier_declarator_list @code{;}
@end example

Notice that generic cursors have neither a predicate nor an orderby
clause. Also note that generic cursors are based on the element type and
not on the container name like ordinary cursors.

Suppose we have two cursors for our prime container: one points to
elements ending in the digit @samp{1} while the other one points to elements
ending in the digit @samp{7}.
Generic cursors allow us to  write one procedure that will print out the
full list of elements that are qualified by these cursors. 

@example
@group
cursor < prime_container > where "($.num%10==1)" prime_one;
cursor < prime_container > where "($.num%10==7)" prime_seven;

typedef generic_cursor < prime_num_type > GC;

void print_primes(GC gc) 
@{
  foreach(gc)
    printf("%d\n",gc.num); // print prime number
@}

main()
@{
    ...
    print_primes ( (GC) &prime_one);
    print_primes ( (GC) &prime_seven);
@}
@end group
@end example

The @code{print_primes} procedure will work for all cursors whose
containers are of type @code{prime_num_type}, regardless of the
concrete cursor's ordering or qualification.

@c ======================================================================

@ignore
@ Schema Declaration, Composite Cursors, Cursor Declaration, P2 Language
@ Schema Declaration

@cindex schema declaration

Schema declarations are used to set up relationship between
containers, i.e. mostly link processing.
The syntax is:

@example
@group
schema_declaration: @code{schema} identifier1 @code{stored_as} identifier2
                    @code{@{} schema_member_declaration+ @code{@}} @code{;}
                    ddlhint_list_opt
schema_member_declaration: @code{db_container} @code{<} type_specifier @code{>} identifier @code{;} 
@end group
@end example

@end ignore

@c ======================================================================

@node Element Keyword, Comprehensive Example, Generic Containers/Cursors, P2 Language
@section Element Keyword

@cindex element keyword

The element keyword refers to the element type
of the given container or cursor @var{k_or_c_name}.
This is useful, for example, when we need to know the size of the
element after it has been transformed by P2. 

@example
@code{element} @code{<} k_or_c_name @code{>} 
@end example

For instance, if we want to find out the overhead for storing the prime
number elements in the container prime_container, we can determine this
using:

@example
@group
    element < prime_cursor > e_prime;

    int orig = sizeof(prime_num_type);
    int new  = sizeof(e_prime);

    printf("Size of prime_num_type:             %d\n",orig);
    printf("Size of element in prime container: %d\n",new );
    printf("Overhead for storing primes:        %d\n",new-orig);
@end group
@end example

In addition, if we want to assign values directly from the cursor
objects, we can use @code{element} to do this:

@example
@group
@{
    ...
    element < emp_curs1 > *c1;
    c1 = emp_curs1.obj;
    printf("%s %d\n",c1->name, c1->age);
@}
@end group
@end example

Here, @code{c1} is declared as a pointer to the  object type of
@code{emp_curs1}. Once the assignment has been made in the second line,
@code{c1} can reference the fields of @code{emp_type}.


@c =====================================================================

@node Comprehensive Example, Type Expression Constraints, Element Keyword, P2 Language
@section Comprehensive Example

Let us see how everything fits so far with an example involving the
previous sections. The program is called @file{prime.p2}.

@smallexample
@c prime.p2.texi is generated automatically
@c from paces/prime.p2 by paces/Makefile.in (JAT)
@include prime.p2.texi
@end smallexample

The first part of the program defines the prime element structure, which
is just a single integer. Next comes the two type definitions. Both of
these type expressions includes the layer @code{cardinality} because it
is this layer that will define the @code{cardinality} operation that
will be used in @code{print_cardinality}.

The second part defines two containers. The first one will be used to
hold all the prime numbers while the second one will be used to hold all
prime numbers ending in the digit @samp{1}.
The second container is, however, constrained to hold only 10 primes
due to the @code{array size is MAX_ARRAY} statement.
A generic container is defined and will be used in the
@code{print_cardinality} procedure.

The third part defines several cursors.
The first two cursors belong to the first container
and the second two belong to the second container.
Notice that the second container has the values sorted in decreasing order. 
Also in these container definitions, the expression @code{$.num % 10}
has to be written without spaces and within parentheses because it is an
unstructured term (what made it unstructured was the arithmetic
operation @code{%}). Finally a generic cursor is declared. 

The fourth part defines two element types. The @code{prime_cont1_type}
will be of type whatever the element of @code{prime_cont1} is. 

The fifth part declares a global int called @code{maxnum}. This is the maximum
value of the number to search for primes.

The sixth part declares three generic-based procedures. The procedure
@code{print} will take any cursor belonging to a container and print out
the list of primes that are accessible by the cursor. For instance, the
cursor @code{c12} will print out only those primes that end in @samp{1},
even though it belongs to the container which stores all primes. 

The @code{print_cardinality} takes a container for an argument and prints out
the size of the container. 

The @code{init_primes} takes a container and inserts all primes up to
but not including the maximum number. At the end, it inserts the number
@samp{2} into the container. Insertions are done via a record of the
original type. This record, called @code{node}, is allocated one and the
values are overwritten per iteration of the loop. Insertions work by
copying the record fields and allocating new memory to store these
fields. 

The seventh part is the main program. The first eight  lines initializes
the containers and cursors and prompts for the maximum value to halt the
search for primes. 

To call the @code{init_primes} procedure to insert elements into the
first container, the address of @emph{any} cursor belonging to the first
container is passed and it is cast to the generic procedure type. While
the syntax may look clumsy, it works. 

Once all the primes are inserted into the first container, we wish to
insert all primes ending in the digit @samp{1} into the second container.
The cursor @code{c12} points to the only numbers we want and is a member of
the first container. Therefore this is the cursor to use in the
@code{foreach} statement. 

Within the @code{foreach} body, we make a test to see if there are already 10
elements in the second container with the operation @code{overflow}. If
the value is true, then the capacity of the container has been reached
meaning it is unable to accept more elements. Therefore, this condition
will break the loop, just like any other C @code{for} loop. 
But as long as it is possible, the number from @code{c12} is copied to a
record and that record is inserted into the second container. 

The program next prints the size of some types and then the program
prints both the content and the size of the two containers. 

The execution of the program resulted in these output:

@smallexample
%prime 100
size of container #1 structure is: 16
size of container #2 structure is: 16
size of elements are: 4

Container #1:
  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47
  53  59  61  67  71  73  79  83  89  97 
cardinality of all primes container =  25

Container #2 -- 1s only:
 71  61  41  31  11 
cardinality of primes ending in 1 container =  5

% prime 250
reached container 2 capacity
size of container #1 structure is: 16
size of container #2 structure is: 16
size of elements are: 4

Container #1:
  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47 
 53  59  61  67  71  73  79  83  89  97 101 103 107 109 113 
127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 
199 211 223 227 229 233 239 241 
cardinality of all primes container =  53

Container #2 -- 1s only:
191 181 151 131 101  71  61  41  31  11 
cardinality of primes ending in 1 container =  10
@end smallexample

Notice how in the second run, the second container reached its capacity.
Also notice that the second container orders the numbers backward.

@c ======================================================================


@node Type Expression Constraints, Composite Cursors, Comprehensive Example, P2 Language
@section Type Expression Constraints


For a P2 system equipped with 40 layers, the number of type expressions
consisting of exactly 5 layers are approximately (1*37^3*2),
representing @code{ conceptual [ @var{3 layers} [ (transient |
mmap_persistent)]]}, which is over 100,000 expressions.  There is one
test suite case in P2 where a type expression is composed
 of  60 layers, so there are a tremendous number of
combinations for type expressions.

However, not all type expressions make sense; only a very small subset
does. Type expressions are constrained by three factors:

@itemize @bullet
@item 
Interface connections

@item
Semantic constraints

@item 
Layer Ordering
@end itemize

@menu
* Interface Constraints::       
* Semantic  Constraints::       
* Ordering   Constraints::      
@end menu

@node Interface Constraints, Semantic  Constraints, Type Expression Constraints, Type Expression Constraints
@subsection Interface Constraints

@cindex interface connection

For a type expression to have the correct interface connection, 
the 
interfaces imported by a layer must  match the interfaces exported by
its arguments. For example, the above type expression 
@code{t = conceptual[odlist[array[transient]]]]} 
is syntactically correct, because:

@itemize @bullet
@item
the parameter of @code{conceptual} is the same  type as the
interface  exported by @code{odlist},

@item
the parameter of @code{odlist} is the same  type as the
interface  exported by @code{array},

@item
the parameter of @code{array} is the same  type as the
interface  exported by @code{transient},

@item
and the @code{transient} layer has no parameters. 
@end itemize

P2 performs  simple compositional transformations at compile time.
Static composition trades the disadvantage that implementations
cannot be altered (a la schema evolution) at run time,
for the advantage that composition has zero runtime cost.
P2 generates code on a per special operation (@pxref{P2 Operations}) basis.
Specifically, P2 composes code fragments contributed by each layer
in the type expression in order down from the top of the type expression
to the bottom, and then back up from the bottom to the top.

@node Semantic  Constraints, Ordering   Constraints, Interface Constraints, Type Expression Constraints
@subsection Semantic  Constraints


@cindex semantic constraints

Once a type expression has the proper interface connections, the next
check is for proper semantic constraints.  For example, one cannot
perform a retrieval operation on a cursor that is bound to a container
with type expression @code{conceptual[malloc[mmap_persistent]]}, since
none of the components in this type expression implement retrieval
operations.  The purpose of P2's built-in design rule checker is to
evaluate additional rules (beyond interface matching) to assure that the
type equations are semantically meaningful. In addition, the built-in
checker will explain in some detail what is wrong with an incorrect type
expression.

For further details on the design rule checking algorithm, see
@ref{Layer Composition Checks, , , p2-adv, Advanced P2 System Manual}.


@node Ordering   Constraints,  , Semantic  Constraints, Type Expression Constraints
@subsection Ordering  Constraints


Finally, a type expression that satisfies the semantic constraints may
work, but the ordering of the layers in the expression may be crucial.
The placement of a layer in a type expression can have a
tremendous effect on the algorithms (and consequently, the running
times). 
Consider the two type expressions below:

@example
@group
typex @{ 
    t = conceptual[delflag[odlist[array[transient]]]];    
    s = conceptual[odlist[delflag[array[transient]]]];
@}
@end group
@end example

One of the routines that is affected  is the @code{delete}
operation. This operation in @code{delflag} marks the element and does
not execute the operation in the next layer in the type expression.
So in expression @code{t}, the @code{delete}
operation for @code{odlist} is not called whereas in @code{s} it is.

So how important is this? Well, it depends on 
the cost for testing every element in every operation
to determine if it has been deleted versus
the cost for doing the deletion on an element. 

@c ======================================================

@node Composite Cursors,  , Type Expression Constraints, P2 Language
@section Composite Cursors

@cindex composite cursor
@cindex cursors, composite

Complex data structures consist of multiple containers whose elements
are interconnected by pointers. A relationship among containers @var{C1},
@var{C2}, ..., @var{Cn} is a set of n-tuples
<@var{e1}, @var{e2}, ..., @var{en}> where element @var{ei} is a
member of container C@var{i}. Let us assume that for three containers
A, B, and C, the relationship among containers over specific elements
are:

@example
@{(a3,b1,c1), (a3,b1,c3), (a1,b2,c4), (a2,b3,c2), (a2,b3,c4)@}
@end example

A @dfn{composite cursor} enumerates the n-tuples of a relationship. More
specifically, a composite cursor @code{k} is an n-tuple of cursors, one
cursor per container of a relationship.
A particular n-tuple <e@var{1}, e@var{2}, ..., e@var{n>}
of a relationship is encoded by having the @var{i}th cursor of @code{k}
positioned on element e@var{i}.
By advancing @code{k}, successive n-tuples of a relationship are retrieved.

A composite cursor is declared with a list of cursor-container pairs
which are the name of the cursor internal to this one and the name of
the container to range over. A @dfn{given}  clause specifies  which of
the internal cursors is already bound, a predicate restricts the
elements satisfying the tuple, and a @dfn{valid} clause tests the next
tuple before advances.
A composite cursor has the syntactical form:

@example
@group
composite-cursor-declaration :  @code{compcurs} 
    @code{<} cursor-container-pair-list @code{>} 
    [ @code{given} @code{<} cursor-list @code{>} ]
    [ @code{where} predicate ] 
    [ @code{valid} valid-string ]
cursor-container-pair-list : cc-pair 
    | cursor-container-pair-list @code{,} cc-pair
cc-pair : internal_cursor_name container_name
@end group
@end example

@ignore

    [ @code{orderby} [ direction ] attribute ] variable-decl-list @code{;}

 The @var{cursor-container-pair-list} is a list of (cursor name, container
 name) pairs which 
 are to be bound to objects in a search; the @code{given} clause
 is a list of cursors that are already bound
 to objects (and are not to be rebound). The predicate @var{predicate}
 is a string containing the qualification. Cursor names are prefaced by
 @code{$}. 
 The @code{valid} clause is used to disregard nodes that have been marked
 as being deleted.

@end ignore

There are two new operations which are special to composite
cursors. @dfn{initk(c_curs)} is the operation which initializes
composite cursors and @dfn{foreachk(c_curs)} is the looping construct
for composite cursors.


The type expression of the containers used in composite cursors 
require a link layer to implement the joins between containers. 
If a link layer is not declared, the nested loop link layer
(@code{nloops}) will be automatically provided by P2.
This example declares a composite cursor @code{goldbach}
to determine pairs of prime numbers that differ by 2. 

@example
@group
prime_list = top2ds[inbetween[qualify[delflag[array[transient]]]]];

container < prime_num_type > stored_as prime_list with @{
    array size is 200;
@} prime_container;

compcurs < a prime_container, b prime_container > 
    where "($a.num+2==$b.num)" 
    goldbach;
@end group
@end example

The composite cursor @code{goldbach} is derived from two internal cursors,
@code{a} and @code{b}, both belonging to the same container,
@code{prime_container}. The where clause is an unstructured predicate
because it uses the @code{+} operation. Therefore, it is expressed
without spaces and in parentheses.

The main program can be written as:

@example
@group
main()
@{
    
    ... // @r{Initialize the container with primes}
    
    initk(goldbach);
    foreachk(goldbach) @{ 
        printf("(%d, %d) ",goldbach.a.num, goldbach.b.num);
    @}
@}
@end group
@end example

After @code{prime_container} has been filled with primes (generated
by a procedure not shown), the composite cursor @code{goldbach} is initialized
and the looping construct begins. The output will look like this:

@example
(3, 5) (5, 7) (11, 13) (17, 19) ...
@end example



The next example uses the @code{given} clause. Assuming that the first element
of the composite cursor is already bound to a prime, find all the
primes such that they are within 10 of the first number. This is used
in conjunction with a cursor @code{find_num} positioned on an element in
the prime container. 

@example
@group
cursor < prime_container > where "$.num == input_value" find_num;

compcurs < a prime_container, b prime_container > 
    given < a > 
    where "($a.num+10>=$b.num) && ($a.num-10<=$b.num)" 
    range;

main()
@{
    ...
    init_curs(find_num);
    initk(range);

    printf("Enter a prime number:");
    scanf("%d",&input_value);

    // position the find_num cursor on <input_value> in the container 
    reset_start(find_num);  

    // position the internal cursor a to point to find_num.  
    range.a = find_num;

    printf("%d: ",range.a.num);
    foreachk(range) @{
        printf("%d ", range.b.num);
    @}
    
@}
@end group
@end example

Because the internal cursor @code{a} is used in the given clause, the
program must set @code{a} to some specific value before the
@code{foreachk} operation. This is because the @code{foreachk} operation
understands that cursors in the given clause are already bound to some
value and it will try make some optimizations based on that
information. 
If the user entered the number @samp{17}, then the output would be:

@example
17: 7 11 13 17 19 23
@end example

Now before we demonstrate an example using the @code{valid} clause, we need to
discuss its operation in  detail. 

On every iteration of a @code{foreachk}, a new n-tuple of elements
will be produced.  If no element is updated or deleted, things
remain simple.  However, if an element of an n-tuple is updated,
then the next n-tuple that is to be retrieved may be different
from the n-tuple that would have been retrieved had there been
no update.

Suppose there is a container of employees and a container 
of departments.  The composite cursor below defines ordered
pairs (i.e., 2-tuples) of department and employee objects
that are related (by sharing the same @code{deptno} value):

@example
@group
compcurs < d department_container, e employee_container >
where "$d.deptno == $e.deptno" cc;

foreachk( cc ) 
    @{   printf("(%s, %s)\n", cc.d.name, cc.e.name );   @}
@end group
@end example

What the above @code{foreachk} does is to loop over each (department,
employee) pair that satisfy the join predicate "$d.deptno == $e.deptno".
Suppose this sequences of ordered pairs is:
@example
@group
  (d1,e1), (d1,e2), (d1,e3), (d2,e4), (d2, e5), (d3, e6)
@end group
@end example

Now suppose the following @code{foreachk()} is executed:

@example
@group
foreachk( cc ) @{ delete( cc.d ); @}
@end group
@end example

Note that the department object @samp{d1} is first to be deleted;
this impacts the sequence of ordered pairs in the following way:

@example
@group
  (d1,e1), (d2,e4), (d3,e6)
@end group
@end example

Note that the tuples @samp{(d1,e2), (d1,e3), (d2,e5)} are not produced.
The reason is that that once d1 is deleted, all subsequent tuples in which
it appeared should be deleted as well.

The main problem is that modifications to elements of an
n-tuple identified by a composite cursor will alter the
sequence of n-tuples produced.  A valid query is a predicate
which is used to determine the validity of elements of
an n-tuple.  This predicate is generally @emph{not} the selection
predicate; rather, it is a predicate that merely tests to
see if an element has been modified.  If the valid predicate
is false, then a new n-tuple will need to be generated on
a composite cursor advancement that @emph{does not} include
the element whose valid test has failed.

Generally, valid predicates are usually limited to testing
for deletions (e.g., !deleted($e)) or to updates of
join fields (e.g., join_field_valid(&$d,&$e)).
Our composite cursor should now look like this:

@example
@group
compcurs < d department_container, e employee_container >
    where "$d.deptno == $e.deptno" 
    valid "!deleted($d)" cc;

@end group
@end example

@c ==================================================================

@ignore

There is, unfortunately, one very obscure subtlety about the valid
clause: the portion of the valid clause relating to the internal cursor
that is used for the
innermost loop is ignored. In the previous example, The innermost
internal cursor is @code{e} while the valid clause refers to internal
cursor @code{d}. Had the composite cursor declaration been written like
this:

@example
@group
compcurs < e employee_container, d department_container >
    where "$d.deptno == $e.deptno" 
    valid "!deleted($d)" cc;

@end group
@end example

Then the valid clause would be ignored and the @code{foreachk} loop
would have iterated over all six tuples.

@end ignore
