/* $Id: op-vec-manager.p2,v 45.0 1997/09/19 05:43:54 jthomas Exp $ */
/* Copyright (C) 1997, The University of Texas at Austin. */

/* Test P2_op-vec-manager.p2 */

/* Use curs_id = 1...N
   That is, skip curs_id = 0, which is an illegal cursor id. (JAT) */

/* Note: as a general rule (hidden) identifiers of the form P2_xxx
   (such as P2_OP_VEC) should never be directly referred to in the
   source code of user programs.  These identifiers should only be
   referred to in generated code, (such as the code generated by
   log.h).  This program is an exception to this rule. (JAT) */

/*****************************************************************************/
/*                  Includes.                                                */
/*****************************************************************************/

#include <assert.h>
#include <stdio.h>
#include "P2_paces.h"

#if 0
/* P2 will automatically #include "P2_op-vec-manager.h" */
#include "P2_op-vec-manager.h" /* P2_OP_VEC */
#endif

#include "print-log.h"         /* P2_PRINT_LOG */

/*****************************************************************************/
/*                  Defines.                                                */
/*****************************************************************************/

#define N 100

/*****************************************************************************/
/*                  foo_func.                                                */
/*****************************************************************************/

/* This function prints its argument. */

int
foo_func (int i)
{
  printf("%d\n", i);
  return(1);
}

/*****************************************************************************/
/*                  Global Variables.                                        */
/*****************************************************************************/

typex {
  foo_typex = top2ds[init_generic[generic[generic_funcall[qualify[
		id[malloc[transient]]]]]]];
}

typedef struct {
  int i;
} FOO_STRUCT;

container <FOO_STRUCT> stored_as foo_typex with {
} foo_cont;

cursor <foo_cont> foo_curs[N];

P2_OP_VEC foo_op_vec;

#if defined(P2_PRINT_LOG)
P2_OP_NAME_VEC foo_op_name_vec = { "foo_func", 0 };
#endif /* P2_PRINT_LOG */

int id;

/*****************************************************************************/
/*                  Main.                                                    */
/*****************************************************************************/

int
main()
{
  /*** Initialize ***/

#if 1
  /* Initialize the log manager FIRST, because the log manager data
     is memory mapped persistent, and we always want it to be mapped
     at the same address (in subsequent paces files). */
  P2_init_log_manager();
#endif
  P2_init_op_vec_manager();

  /* Allocate an operation vector of size 1
     (i.e. containing a single function pointer). */
  foo_op_vec = (P2_OP_VEC) malloc(sizeof(void*));

  /* Initialize the function pointer to point to foo_func() */
  foo_op_vec[0] = &foo_func;

  /*** Test ****/

  open_cont(foo_cont);

  /* For each curs_id = 1...99, assign op_vec[id] = foo_op_vec */

  for (id = 1; id < N; id++)
  {
    init_curs(foo_curs[id]);
#if defined(P2_PRINT_LOG)
    P2_put_op_vec(id, foo_op_vec, foo_op_name_vec);
#else
    P2_put_op_vec(id, foo_op_vec);
#endif /* P2_PRINT_LOG */
  }

  /* For each curs_id = 1...99, assign foo_op_vec = op_vec[id].
     foo_op_vec should be non-NULL.
     foo_op_vec[0] should be non-NULL and equal to the address of foo_func().
     When called, (*f[0])(id) whould print id = 1...99 */

  for (id = 1; id < N; id++)
  {
    foo_op_vec = P2_get_op_vec(id);
    assert(foo_op_vec != NULL);
    assert(foo_op_vec[0] != NULL);
    assert(foo_op_vec[0] == &foo_func);
    (*foo_op_vec[0])(id);
  }

  /*** Exit ***/

  P2_delete_op_vec_manager();
#if 1
  /* Delete the log manager LAST. */
  P2_delete_log_manager();
#endif

  return(0);
}
